---
title: "Lesson 2: Working with data frames"
author: "Quentin D. Read"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output: 
  html_document:
    toc: true
    toc_depth: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = TRUE, warning = TRUE)
```

# Learning objectives

At the end of this lesson, students will ...

- Read a CSV file of data into the R workspace.
- Know what a data frame is and understand what constitutes "tidy" data.
- Calculate summary statistics by group.
- Make a few basic plots.

# What is a data frame?

We will not go into every possible R data type for this lesson. The one you really need to know about for model fitting is the data frame.

A data frame corresponds to a table or spreadsheet of data. Each column has its own data type. You might have numeric, character, and factor columns all in the same data frame. Ideally, each row will correspond to an individual observation.

What are some things you can do with a data frame? 

- dim()
- nrow(), ncol()
- names()
- str()
- summary()
- head()
- tail()

# Loading packages

Note we are going to use tidyverse packages.

# Reading in data

If you are using RStudio Cloud, the file `xxxx.csv` is included in the `datasets` folder. Otherwise, you will need to download the file locally and replace `datasets` with the file path to the location on your system where the file is found. For example it might be `C:/Users/yourname/Documents/r_workshop_datasets/xxxx.csv`. Notice that `/` (forward slash) is used, even on Windows!

Load the packages we'll need for this library. Read in an external file using the `read_csv()` function from the tidyverse package **readr**. There is a base R function for this as well but the **readr** function has better default values and reads large files more quickly. Also, `read_csv` returns a special kind of data frame called a "tibble" that works better with the other tidyverse functions.

```{r}
library(tidyverse)
library(lmerTest)

dat <- read_csv('datasets/testdata.csv')
```

# Examining contents of a data frame

- dimensions
- names of rows and columns
- index by row number, column number, row name, and column name

## Summary information about a data frame

Let's look at the object which is now loaded into our workspace that we are calling `dat`. (I don't like to use `data` or `df` because there are already base R functions with those names, and it can cause issues down the road.)

If we just type `dat` into our console we see the first few rows of data and some information about its dimensions.

```{r}
dat
```

As the informational text says, we can print all the values of `dat` if we explicitly tell R to do this. It's nice that it does not do this by default especially if we have data frames with thousands or millions of rows.

```{r}
print(dat, n = 50)
```

Some other useful functions to examine a data frame are `summary()` and `str()` from base R, and `glimpse()` from tidyverse. Try calling them and see what output you get.

## Subsetting values from a data frame

If we want to print only specific subsets of the data, we can do that by indexing rows and columns. The square brackets `[]` are used for this. You can get individual elements of a data frame with brackets. The syntax is `dataframe[row, column]`. For example this will return the value in row 2, column 3 of the data frame. It actually returns a 1x1 tibble.

```{r}
dat[2, 3]
```

We can also get an entire row by leaving the `column` part blank, and an entire column by leaving the `row` part blank. This gives us the 5th row:

```{r}
dat[5, ]
```

and this gives us the 2nd column:

```{r}
dat[, 2]
```

We can also subset with ranges, for example this gives us the 6th through 10th rows, including all columns:

```{r}
dat[6:10, ]
```

and this gives us the first 5 rows, but only columns 1 and 2.

```{r}
dat[1:5, 1:2]
```

You can also get columns by name. Just make sure to pass the vector of column names using the `c()` function, and put quotes around the names:

```{r}
dat[, c('x', 'y')]
```

The tidyverse functions `filter()` and `select()` are used to give you subsets of rows and columns, respectively. A common use of `filter()` is to subset rows by a certain condition. For example we can use `filter()` to get all rows where `y` is less than 10.

```{r}
filter(dat, y < 10)
```

And we can use `select()` to get columns we want. We do not need to use quotes on column names within `select()`:

```{r}
select(dat, x, y)
```

# Calculating summary statistics

We can calculate summary statistics on the entire data frame.

# Dealing with missing data

Summary methods for data frames tell you how many missing values there are.

Many R functions that calculate summary statistics return a `NA` value if there are any missing values in the dataset. Let's look at `max()`:

```{r}
x <- c(5.3, 12.2, -8.6)

x

max(x)

x[2] <- NA

x

max(x)
```


Where there's data, there's missing data. There are lots of ways to deal with missing data. For now we will do the simplest thing, ignore it.

The R functions `mean()`, `min()`, `max()`, and `sum()` have an argument `na.rm = TRUE` which removes `NA` values before computing the summary statistic. Its default value is `FALSE` so you need to explicitly set it to `TRUE` if you want to calculate the summary statistics without the missing values.

```{r}
max(x, na.rm = TRUE)
```


Note `na.rm` serves a useful purpose and I think it's a good idea to have `FALSE` be the default.

Let's calculate summary statistics for entire columns of a data frame. Here I am introducing the pipe `%>%` operator. This is used in tidyverse packages to chain functions together. We can pass the output of one line of code to the next.

```{r}
dat %>%
  summarize(mean_x = mean(x), sd_x = sd(x), mean_y = mean(y), sd_y = sd(y))
```

# Calculating summary statistics by group

You often want to calculate summary statistics for each group. We will use the `group_by()` function here.

```{r}
dat %>%
  group_by(group)
  summarize(mean_x = mean(x), sd_x = sd(x), mean_y = mean(y), sd_y = sd(y))
```

# Other common operations on data frames

- `pivot_longer()`
- `pivot_wider()`

# Tidy data

This set of examples is borrowed from Hadley Wickham's book *R for Data Science* ([Chapter 12: Tidy data](https://r4ds.had.co.nz/tidy-data.html)).

Tidy data is a dataset that is organized so that the following are true:

- Each observation has its own row.
- Each variable has its own column.
- Each value has its own cell.

Most of the model fitting functions in R require the data to be in this format (as well as many statistical procedures in SAS and other software).

All of the following data frames contain the same data: number of cases of a disease and total population, for three different countries (Afghanistan, Brazil, and China), in each of two years (1999 and 2000). Which of these data frames contain tidy data? 

> These are example datasets that come packaged with the **tidyr** package in R, part of the tidyverse.

```{r}
table1
table2
table3
```

INSERT DESCRIPTION HERE

# Reshaping data

```{r}
# FIXME WE ARE GOING TO INCLUDE SOME STUFF ABOUT RESHAPING HERE
```


# Make a basic plot

We will use the **ggplot2** package for plotting. In this workshop I will not explain how these plots work in great detail, but I plan to offer workshops on data visualization in the future.

As a brief intro, we can "map" different columns of the data frame to different components of the plot. This is known as "aesthetic mapping" hence the function name `aes()`. For example, in this fake data frame, we map the `x` column to the x-axis aesthetic, the `y` column to the y-axis aesthetic, and the `g` column, which consists of letters, to the color aesthetic.

Then you use the plus sign `+` to add "geoms" to the plot which correspond to different types of data visualizations you are probably familiar with. For instance `geom_point()` is a scatterplot.

(insert cheat sheet)

```{r, fig.width = 4, fig.height = 4}
ggplot(dat, aes(x = x, y = y, color = g, fill = g)) +
  geom_point()
```

As you can see, different types of plots can be made by changing the geom, with the variable mappings unchanged, such as a line graph or a stacked bar plot. The data are the same.

```{r, fig.width = 4, fig.height = 4}
ggplot(dat, aes(x = x, y = y, color = g, fill = g)) +
  geom_line()

ggplot(dat, aes(x = x, y = y, color = g, fill = g)) +
  geom_col()
```

Additional arguments can be added to change the appearance of the plot, alter the geoms, or add other graphical elements that are not mapped from the data frame. For instance we can change our stacked bar plot to a grouped bar plot by an argument to `geom_col()`. Then we can change the theme by adding `theme_bw()`, and also add a horizontal dotted line on the plot by adding another geom.

```{r}
barplot <- ggplot(dat, aes(x = x, y = y, color = g, fill = g)) +
  geom_col(position = 'dodge')

barplot

barplot + theme_bw()

barplot + theme_bw() + geom_hline(yintercept = 15, linetype = 'dotted')
```

# Hey! What about ...

- Joining two or more data frames together
- Operations on lists of data frames or data frames containing lists

Those are very important topics that you will definitely need to learn about if you want to do serious data analysis with R. We don't have time to cover them today but I would recommend using the R resources I posted on the workshop page to learn more about them.

# Exercises

TBD