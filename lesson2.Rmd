---
title: "Lesson 2: Working with data frames"
author: "Quentin D. Read"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output: 
  html_document:
    toc: true
    toc_depth: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = TRUE, warning = TRUE)
```

# Learning objectives

At the end of this lesson, students will ...

- Read a CSV file of data into the R workspace.
- Know what a data frame is and understand what constitutes "tidy" data.
- Calculate summary statistics by group.
- Make a few basic plots.

# What is a data frame?

We will not go into every possible R data type for this lesson. The one you really need to know about for model fitting is the data frame.

A data frame corresponds to a table or spreadsheet of data. Each column has its own data type. You might have numeric, character, and factor columns all in the same data frame. Ideally, each row will correspond to an individual observation.

What are some things you can do with a data frame? 

- dim()
- nrow(), ncol()
- names()
- str()
- summary()
- head()
- tail()

# Loading packages

Note we are going to use tidyverse packages.

# Reading in data

If you are using RStudio Cloud, the file `xxxx.csv` is included in the `datasets` folder. Otherwise, you will need to download the file locally and replace `datasets` with the file path to the location on your system where the file is found. For example it might be `C:/Users/yourname/Documents/r_workshop_datasets/xxxx.csv`. Notice that `/` (forward slash) is used, even on Windows!

Load the packages we'll need for this library. Read in an external file using the `read_csv()` function from the tidyverse package **readr**. There is a base R function for this as well but the **readr** function has better default values and reads large files more quickly. Also, `read_csv` returns a special kind of data frame called a "tibble" that works better with the other tidyverse functions.

```{r}
library(tidyverse)
library(lmerTest)

dat <- read_csv('datasets/testdata.csv')
```

# Examining contents of a data frame

- dimensions
- names of rows and columns
- index by row number, column number, row name, and column name

## Summary information about a data frame

Let's look at the object which is now loaded into our workspace that we are calling `dat`. (I don't like to use `data` or `df` because there are already base R functions with those names, and it can cause issues down the road.)

If we just type `dat` into our console we see the first few rows of data and some information about its dimensions.

```{r}
dat
```

As the informational text says, we can print all the values of `dat` if we explicitly tell R to do this. It's nice that it does not do this by default especially if we have data frames with thousands or millions of rows.

```{r}
print(dat, n = 50)
```

Some other useful functions to examine a data frame are `summary()` and `str()` from base R, and `glimpse()` from tidyverse. Try calling them and see what output you get.

## Subsetting values from a data frame

If we want to print only specific subsets of the data, we can do that by indexing rows and columns. The square brackets `[]` are used for this. You can get individual elements of a data frame with brackets. The syntax is `dataframe[row, column]`. For example this will return the value in row 2, column 3 of the data frame. It actually returns a 1x1 tibble.

```{r}
dat[2, 3]
```

We can also get an entire row by leaving the `column` part blank, and an entire column by leaving the `row` part blank. This gives us the 5th row:

```{r}
dat[5, ]
```

and this gives us the 2nd column:

```{r}
dat[, 2]
```

We can also subset with ranges, for example this gives us the 6th through 10th rows, including all columns:

```{r}
dat[6:10, ]
```

and this gives us the first 5 rows, but only columns 1 and 2.

```{r}
dat[1:5, 1:2]
```

You can also get columns by name. Just make sure to pass the vector of column names using the `c()` function, and put quotes around the names:

```{r}
dat[, c('x', 'y')]
```

The tidyverse functions `filter()` and `select()` are used to give you subsets of rows and columns, respectively. A common use of `filter()` is to subset rows by a certain condition. For example we can use `filter()` to get all rows where `y` is less than 10.

```{r}
filter(dat, y < 10)
```

And we can use `select()` to get columns we want. We do not need to use quotes on column names within `select()`:

```{r}
select(dat, x, y)
```

# Calculating summary statistics

We can calculate summary statistics on the entire data frame.

# Dealing with missing data

Summary methods for data frames tell you how many missing values there are.

Many R functions that calculate summary statistics return a `NA` value if there are any missing values in the dataset. Let's look at `max()`:

```{r}
x <- c(5.3, 12.2, -8.6)

x

max(x)

x[2] <- NA

x

max(x)
```


Where there's data, there's missing data. There are lots of ways to deal with missing data. For now we will do the simplest thing, ignore it.

The R functions `mean()`, `min()`, `max()`, and `sum()` have an argument `na.rm = TRUE` which removes `NA` values before computing the summary statistic. Its default value is `FALSE` so you need to explicitly set it to `TRUE` if you want to calculate the summary statistics without the missing values.

```{r}
max(x, na.rm = TRUE)
```


Note `na.rm` serves a useful purpose and I think it's a good idea to have `FALSE` be the default.

Let's calculate summary statistics for entire columns of a data frame. Here I am introducing the pipe `%>%` operator. This is used in tidyverse packages to chain functions together. We can pass the output of one line of code to the next.

```{r}
dat %>%
  summarize(mean_x = mean(x), sd_x = sd(x), mean_y = mean(y), sd_y = sd(y))
```

# Calculating summary statistics by group

You often want to calculate summary statistics for each group. We will use the `group_by()` function here.

```{r}
dat %>%
  group_by(group)
  summarize(mean_x = mean(x), sd_x = sd(x), mean_y = mean(y), sd_y = sd(y))
```

# Other common operations on data frames

- `filter()`
- `pivot_longer()`
- `pivot_wider()`

# Long-form data

Usually, we want to have long form data rather than wide. You may also see this referred to as "tidy" data. In long-form or tidy data, each row represents a single data point or observation. Each column represents a single variable. Most of the model fitting functions in R require the data to be in this format (as well as many statistical procedures in SAS and other software).

Which of these data frames contain tidy data? I am using the `head()` function to show the first few rows.

> These are example datasets that come packaged with R. You can call up documentation on them by entering `?ToothGrowth` or `help(package = 'datasets')` to see a list of all of them.

```{r}
head(ToothGrowth)
```

Here `len` is tooth length, `supp` is type of Vitamin C supplement, and `dose` is the dose of supplement administered. **YES!** this is tidy data! (Each row is one individual's measurement.)

```{r}
euro.cross
```

Different countries' currencies are across both rows and columns. Each cell contains the exchange rate between the two. **NO!** this is not tidy data! (Each row contains many data points.)

```{r}
head(swiss)
```

These are socioeconomic indicators for different regions of Switzerland in 1888. **YES!** this is tidy data! (Each row contains the variables associated with one region.)

```{r}
mdeaths
```

These are monthly deaths from lung disease in the United Kingdom in the 1970s. **MAYBE!** this may be tidy depending on your research goal. (If you are comparing months to each other within years, yes it is tidy, but if you are looking at the overall time series, you would want to reshape to have each combination of year and month in its own row.)

# Making untidy data tidy

```{r}
# FIXME
```


# Make a basic plot

We will use the **ggplot2** package for plotting. In this workshop I will not explain how these plots work in great detail, but I plan to offer workshops on data visualization in the future.

As a brief intro, we can "map" different columns of the data frame to different components of the plot. This is known as "aesthetic mapping" hence the function name `aes()`. For example, in this fake data frame, we map the `x` column to the x-axis aesthetic, the `y` column to the y-axis aesthetic, and the `g` column, which consists of letters, to the color aesthetic.

Then you use the plus sign `+` to add "geoms" to the plot which correspond to different types of data visualizations you are probably familiar with. For instance `geom_point()` is a scatterplot.

(insert cheat sheet)

```{r, fig.width = 4, fig.height = 4}
ggplot(dat, aes(x = x, y = y, color = g, fill = g)) +
  geom_point()
```

As you can see, different types of plots can be made by changing the geom, with the variable mappings unchanged, such as a line graph or a stacked bar plot. The data are the same.

```{r, fig.width = 4, fig.height = 4}
ggplot(dat, aes(x = x, y = y, color = g, fill = g)) +
  geom_line()

ggplot(dat, aes(x = x, y = y, color = g, fill = g)) +
  geom_col()
```

Additional arguments can be added to change the appearance of the plot, alter the geoms, or add other graphical elements that are not mapped from the data frame. For instance we can change our stacked bar plot to a grouped bar plot by an argument to `geom_col()`. Then we can change the theme by adding `theme_bw()`, and also add a horizontal dotted line on the plot by adding another geom.

```{r}
barplot <- ggplot(dat, aes(x = x, y = y, color = g, fill = g)) +
  geom_col(position = 'dodge')

barplot

barplot + theme_bw()

barplot + theme_bw() + geom_hline(yintercept = 15, linetype = 'dotted')
```

# Exercises

TBD